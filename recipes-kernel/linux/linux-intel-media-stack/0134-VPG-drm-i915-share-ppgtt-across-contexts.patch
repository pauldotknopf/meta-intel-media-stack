From d02374af6340e00924b030a9e3474a010e80707d Mon Sep 17 00:00:00 2001
From: Hong Liu <hong.liu@intel.com>
Date: Thu, 7 Jul 2016 14:03:06 +0800
Subject: [PATCH 134/153] [VPG]: drm/i915: share ppgtt across contexts

With this patch, user space can specify which context it wants to
share ppgtt with.

Several reasons to do this:
1. We can avoid pinning same buffer into different ppgtt, this can reduce
   the CPU utilization time in execbuffer ioctl.
2. With several contexts have same GTT layouts in their own ppgtt table,
   it can cause GPU getting wrong physical memory address when translating
   GTT address to physical address. Sharing the ppgtt across several context
   can avoid this issue.

Signed-off-by: Hong Liu <hong.liu@intel.com>
---
 drivers/gpu/drm/i915/i915_gem_context.c |   30 +++++++++++++++++++++++++-----
 include/uapi/drm/i915_drm.h             |    1 +
 2 files changed, 26 insertions(+), 5 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_gem_context.c b/drivers/gpu/drm/i915/i915_gem_context.c
index 72ad358..e0d156c 100644
--- a/drivers/gpu/drm/i915/i915_gem_context.c
+++ b/drivers/gpu/drm/i915/i915_gem_context.c
@@ -892,7 +892,7 @@ int i915_gem_context_create_ioctl(struct drm_device *dev, void *data,
 	struct drm_i915_gem_context_create *args = data;
 	struct drm_i915_file_private *file_priv = file->driver_priv;
 	struct intel_context *ctx;
-	int ret;
+	int ret = 0;
 
 	if (!contexts_enabled(dev))
 		return -ENODEV;
@@ -902,14 +902,34 @@ int i915_gem_context_create_ioctl(struct drm_device *dev, void *data,
 		return ret;
 
 	ctx = i915_gem_create_context(dev, file_priv);
-	mutex_unlock(&dev->struct_mutex);
-	if (IS_ERR(ctx))
-		return PTR_ERR(ctx);
+	if (IS_ERR(ctx)) {
+		ret = PTR_ERR(ctx);
+		goto out;
+	}
+
+	if (args->pad == I915_GEM_CONTEXT_SHARE_PPGTT) {
+		struct intel_context *share_ctx;
+
+		share_ctx = i915_gem_context_get(file_priv, args->ctx_id);
+		if (IS_ERR(share_ctx)) {
+			ret = PTR_ERR(share_ctx);
+			goto out_free_ctx;
+		}
+
+		i915_ppgtt_get(share_ctx->ppgtt);
+		i915_ppgtt_put(ctx->ppgtt);
+		ctx->ppgtt = share_ctx->ppgtt;
+	}
 
 	args->ctx_id = ctx->user_handle;
 	DRM_DEBUG_DRIVER("HW context %d created\n", args->ctx_id);
 
-	return 0;
+out_free_ctx:
+	idr_remove(&file_priv->context_idr, ctx->user_handle);
+	i915_gem_context_unreference(ctx);
+out:
+	mutex_unlock(&dev->struct_mutex);
+	return ret;
 }
 
 int i915_gem_context_destroy_ioctl(struct drm_device *dev, void *data,
diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index fc57651..38ce5aa 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -1096,6 +1096,7 @@ struct drm_i915_gem_wait {
 	__s64 timeout_ns;
 };
 
+#define I915_GEM_CONTEXT_SHARE_PPGTT 1
 struct drm_i915_gem_context_create {
 	/*  output: id of new context*/
 	__u32 ctx_id;
-- 
1.7.1

