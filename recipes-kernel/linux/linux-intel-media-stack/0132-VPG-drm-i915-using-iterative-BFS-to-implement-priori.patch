From d2408fea3fdc4c5a69b8828d7a1e07d40c833b04 Mon Sep 17 00:00:00 2001
From: Hong Liu <hong.liu@intel.com>
Date: Tue, 21 Jun 2016 10:25:47 +0800
Subject: [PATCH 132/153] [VPG]: drm/i915: using iterative BFS to implement priority bump

Using recursive function may overflow the kernel stack, and causes random
kernel panic.

Change-Id: Ia83175d97acc3ffa51b756c8beb5a1f0ea02ddf0
Signed-off-by: Hong Liu <hong.liu@intel.com>
---
 drivers/gpu/drm/i915/i915_scheduler.c |   48 +++++++++++++++++++-------------
 drivers/gpu/drm/i915/i915_scheduler.h |    4 +++
 2 files changed, 32 insertions(+), 20 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_scheduler.c b/drivers/gpu/drm/i915/i915_scheduler.c
index 678cf83..4d81527 100644
--- a/drivers/gpu/drm/i915/i915_scheduler.c
+++ b/drivers/gpu/drm/i915/i915_scheduler.c
@@ -308,35 +308,43 @@ static int i915_scheduler_priority_bump(struct i915_scheduler *scheduler,
 				struct i915_scheduler_queue_entry *target,
 				uint32_t bump)
 {
-	uint32_t new_priority;
-	int i, count;
-
-	if (target->priority >= scheduler->priority_level_max)
-		return 1;
+	int32_t new_priority;
+	int i, count = 0;
+	LIST_HEAD(queue);
 
 	if (target->bumped)
 		return 0;
 
-	new_priority = target->priority + bump;
-	if ((new_priority <= target->priority) ||
-	    (new_priority > scheduler->priority_level_max))
-		target->priority = scheduler->priority_level_max;
-	else
-		target->priority = new_priority;
-
-	count = 1;
+	list_add_tail(&target->deplink, &queue);
 	target->bumped = true;
 
-	for (i = 0; i < target->num_deps; i++) {
-		if (!target->dep_list[i])
-			continue;
+	while (!list_empty(&queue)) {
+		struct i915_scheduler_queue_entry *qe;
+
+		qe = list_first_entry(&queue,
+				struct i915_scheduler_queue_entry, deplink);
+		list_del(&qe->deplink);
+		count++;
 
-		if (target->dep_list[i]->bumped)
+		if (qe->priority >= scheduler->priority_level_max)
 			continue;
 
-		count += i915_scheduler_priority_bump(scheduler,
-						      target->dep_list[i],
-						      bump);
+		new_priority = qe->priority + bump;
+		if ((new_priority <= qe->priority) ||
+		    (new_priority > scheduler->priority_level_max))
+			qe->priority = scheduler->priority_level_max;
+		else
+			qe->priority = new_priority;
+
+		for (i = 0; i < qe->num_deps; i++) {
+			if (!qe->dep_list[i] || qe->dep_list[i]->bumped)
+				continue;
+
+			list_add_tail(&qe->dep_list[i]->deplink, &queue);
+			/* need to set flag early to avoid entry being
+			 * added to queue multiple times */
+			qe->dep_list[i]->bumped = true;
+		}
 	}
 
 	return count;
diff --git a/drivers/gpu/drm/i915/i915_scheduler.h b/drivers/gpu/drm/i915/i915_scheduler.h
index bcd3f94..bb70847 100644
--- a/drivers/gpu/drm/i915/i915_scheduler.h
+++ b/drivers/gpu/drm/i915/i915_scheduler.h
@@ -87,7 +87,11 @@ struct i915_scheduler_queue_entry {
 
 	/* List of all scheduler queue entry nodes */
 	struct list_head link;
+
+	/* used for priority bump */
+	struct list_head deplink;
 };
+
 const char *i915_qe_state_str(struct i915_scheduler_queue_entry *node);
 
 struct i915_scheduler_stats_nodes {
-- 
1.7.1

